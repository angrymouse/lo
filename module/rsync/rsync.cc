
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <deps/librsync-2.3.4/src/librsync.h>
#include <spin.h>

namespace spin {
namespace rsync {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;



void beginSlow(const FunctionCallbackInfo<Value> &args) {
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  rs_job_t* rc = rs_sig_begin(v0, v1, (rs_magic_number)v2);
  Local<ArrayBuffer> ab = args[3].As<Uint32Array>()->Buffer();
  ((rs_job_t**)ab->Data())[0] = rc;
}

void beginFast(void* p, uint32_t p0, uint32_t p1, int32_t p2, struct FastApiTypedArray* const p_ret) {
  uint32_t v0 = p0;
  uint32_t v1 = p1;
  int32_t v2 = p2;
  rs_job_t* r = rs_sig_begin(v0, v1, (rs_magic_number)v2);
  ((rs_job_t**)p_ret->data)[0] = r;

}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  rs_job_t* v0 = reinterpret_cast<rs_job_t*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = rs_job_free(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t freeFast(void* p, void* p0) {
  rs_job_t* v0 = reinterpret_cast<rs_job_t*>(p0);
  return rs_job_free(v0);
}
void iterSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  rs_job_t* v0 = reinterpret_cast<rs_job_t*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  rs_buffers_t* v1 = reinterpret_cast<rs_buffers_t*>(ptr1);
  int32_t rc = rs_job_iter(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t iterFast(void* p, void* p0, struct FastApiTypedArray* const p1) {
  rs_job_t* v0 = reinterpret_cast<rs_job_t*>(p0);
  rs_buffers_t* v1 = reinterpret_cast<rs_buffers_t*>(p1->data);
  return rs_job_iter(v0, v1);
}
void argsSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  uint32_t v0 = Local<Integer>::Cast(args[0])->Value();
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  rs_magic_number* v1 = reinterpret_cast<rs_magic_number*>(ptr1);
  Local<Uint32Array> u322 = args[2].As<Uint32Array>();
  uint8_t* ptr2 = (uint8_t*)u322->Buffer()->Data() + u322->ByteOffset();
  size_t* v2 = reinterpret_cast<size_t*>(ptr2);
  Local<Uint32Array> u323 = args[3].As<Uint32Array>();
  uint8_t* ptr3 = (uint8_t*)u323->Buffer()->Data() + u323->ByteOffset();
  size_t* v3 = reinterpret_cast<size_t*>(ptr3);
  int32_t rc = rs_sig_args(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t argsFast(void* p, uint32_t p0, struct FastApiTypedArray* const p1, struct FastApiTypedArray* const p2, struct FastApiTypedArray* const p3) {
  uint32_t v0 = p0;
  rs_magic_number* v1 = reinterpret_cast<rs_magic_number*>(p1->data);
  size_t* v2 = reinterpret_cast<size_t*>(p2->data);
  size_t* v3 = reinterpret_cast<size_t*>(p3->data);
  return rs_sig_args(v0, v1, v2, v3);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  v8::CTypeInfo* cargsbegin = (v8::CTypeInfo*)calloc(5, sizeof(v8::CTypeInfo));
  cargsbegin[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsbegin[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsbegin[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsbegin[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  cargsbegin[4] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcbegin = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infobegin = new v8::CFunctionInfo(*rcbegin, 5, cargsbegin);
  v8::CFunction* pFbegin = new v8::CFunction((const void*)&beginFast, infobegin);
  SET_FAST_METHOD(isolate, module, "begin", pFbegin, beginSlow);

  v8::CTypeInfo* cargsfree = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsfree[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsfree[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcfree = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infofree = new v8::CFunctionInfo(*rcfree, 2, cargsfree);
  v8::CFunction* pFfree = new v8::CFunction((const void*)&freeFast, infofree);
  SET_FAST_METHOD(isolate, module, "free", pFfree, freeSlow);

  v8::CTypeInfo* cargsiter = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsiter[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsiter[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsiter[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rciter = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoiter = new v8::CFunctionInfo(*rciter, 3, cargsiter);
  v8::CFunction* pFiter = new v8::CFunction((const void*)&iterFast, infoiter);
  SET_FAST_METHOD(isolate, module, "iter", pFiter, iterSlow);

  v8::CTypeInfo* cargsargs = (v8::CTypeInfo*)calloc(5, sizeof(v8::CTypeInfo));
  cargsargs[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsargs[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsargs[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsargs[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsargs[4] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcargs = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoargs = new v8::CFunctionInfo(*rcargs, 5, cargsargs);
  v8::CFunction* pFargs = new v8::CFunction((const void*)&argsFast, infoargs);
  SET_FAST_METHOD(isolate, module, "args", pFargs, argsSlow);

  SET_MODULE(isolate, target, "rsync", module);
}
} // namespace rsync
} // namespace spin

extern "C" {
  void* _register_rsync() {
    return (void*)spin::rsync::Init;
  }
}
