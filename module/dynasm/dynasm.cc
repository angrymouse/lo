
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <dasm_proto.h>
#include <dasm_x86.h>
#include <spin.h>

namespace spin {
namespace dynasm {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;



void initSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  dasm_init(v0, v1);
}

void initFast(void* p, struct FastApiTypedArray* const p0, int32_t p1) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  int32_t v1 = p1;
  dasm_init(v0, v1);
}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  dasm_free(v0);
}

void freeFast(void* p, struct FastApiTypedArray* const p0) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  dasm_free(v0);
}
void setupglobalSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  void** v1 = reinterpret_cast<void**>(ptr1);
  uint32_t v2 = Local<Integer>::Cast(args[2])->Value();
  dasm_setupglobal(v0, v1, v2);
}

void setupglobalFast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1, uint32_t p2) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  void** v1 = reinterpret_cast<void**>(p1->data);
  uint32_t v2 = p2;
  dasm_setupglobal(v0, v1, v2);
}
void growpcSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  dasm_growpc(v0, v1);
}

void growpcFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  uint32_t v1 = p1;
  dasm_growpc(v0, v1);
}
void setupSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  const void* v1 = reinterpret_cast<const void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  dasm_setup(v0, v1);
}

void setupFast(void* p, struct FastApiTypedArray* const p0, void* p1) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  const void* v1 = reinterpret_cast<const void*>(p1);
  dasm_setup(v0, v1);
}
void putSlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  dasm_put(v0, v1, v2);
}

void putFast(void* p, struct FastApiTypedArray* const p0, int32_t p1, int32_t p2) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  int32_t v1 = p1;
  int32_t v2 = p2;
  dasm_put(v0, v1, v2);
}
void linkSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  Local<Uint32Array> u321 = args[1].As<Uint32Array>();
  uint8_t* ptr1 = (uint8_t*)u321->Buffer()->Data() + u321->ByteOffset();
  size_t* v1 = reinterpret_cast<size_t*>(ptr1);
  int32_t rc = dasm_link(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t linkFast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  size_t* v1 = reinterpret_cast<size_t*>(p1->data);
  return dasm_link(v0, v1);
}
void encodeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  void* v1 = reinterpret_cast<void*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t rc = dasm_encode(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t encodeFast(void* p, struct FastApiTypedArray* const p0, void* p1) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  void* v1 = reinterpret_cast<void*>(p1);
  return dasm_encode(v0, v1);
}
void getpclabelSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = dasm_getpclabel(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t getpclabelFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1) {
  dasm_State ** v0 = reinterpret_cast<dasm_State **>(p0->data);
  uint32_t v1 = p1;
  return dasm_getpclabel(v0, v1);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);

  v8::CTypeInfo* cargsinit = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsinit[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsinit[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsinit[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CTypeInfo* rcinit = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infoinit = new v8::CFunctionInfo(*rcinit, 3, cargsinit);
  v8::CFunction* pFinit = new v8::CFunction((const void*)&initFast, infoinit);
  SET_FAST_METHOD(isolate, module, "init", pFinit, initSlow);

  v8::CTypeInfo* cargsfree = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsfree[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsfree[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcfree = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infofree = new v8::CFunctionInfo(*rcfree, 2, cargsfree);
  v8::CFunction* pFfree = new v8::CFunction((const void*)&freeFast, infofree);
  SET_FAST_METHOD(isolate, module, "free", pFfree, freeSlow);

  v8::CTypeInfo* cargssetupglobal = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargssetupglobal[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargssetupglobal[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargssetupglobal[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargssetupglobal[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  v8::CTypeInfo* rcsetupglobal = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infosetupglobal = new v8::CFunctionInfo(*rcsetupglobal, 4, cargssetupglobal);
  v8::CFunction* pFsetupglobal = new v8::CFunction((const void*)&setupglobalFast, infosetupglobal);
  SET_FAST_METHOD(isolate, module, "setupglobal", pFsetupglobal, setupglobalSlow);

  v8::CTypeInfo* cargsgrowpc = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsgrowpc[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsgrowpc[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsgrowpc[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  v8::CTypeInfo* rcgrowpc = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infogrowpc = new v8::CFunctionInfo(*rcgrowpc, 3, cargsgrowpc);
  v8::CFunction* pFgrowpc = new v8::CFunction((const void*)&growpcFast, infogrowpc);
  SET_FAST_METHOD(isolate, module, "growpc", pFgrowpc, growpcSlow);

  v8::CTypeInfo* cargssetup = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargssetup[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargssetup[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargssetup[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcsetup = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infosetup = new v8::CFunctionInfo(*rcsetup, 3, cargssetup);
  v8::CFunction* pFsetup = new v8::CFunction((const void*)&setupFast, infosetup);
  SET_FAST_METHOD(isolate, module, "setup", pFsetup, setupSlow);

  v8::CTypeInfo* cargsput = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargsput[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsput[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsput[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  cargsput[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CTypeInfo* rcput = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infoput = new v8::CFunctionInfo(*rcput, 4, cargsput);
  v8::CFunction* pFput = new v8::CFunction((const void*)&putFast, infoput);
  SET_FAST_METHOD(isolate, module, "put", pFput, putSlow);

  v8::CTypeInfo* cargslink = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargslink[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargslink[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargslink[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rclink = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infolink = new v8::CFunctionInfo(*rclink, 3, cargslink);
  v8::CFunction* pFlink = new v8::CFunction((const void*)&linkFast, infolink);
  SET_FAST_METHOD(isolate, module, "link", pFlink, linkSlow);

  v8::CTypeInfo* cargsencode = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsencode[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsencode[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsencode[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcencode = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoencode = new v8::CFunctionInfo(*rcencode, 3, cargsencode);
  v8::CFunction* pFencode = new v8::CFunction((const void*)&encodeFast, infoencode);
  SET_FAST_METHOD(isolate, module, "encode", pFencode, encodeSlow);

  v8::CTypeInfo* cargsgetpclabel = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsgetpclabel[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsgetpclabel[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsgetpclabel[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  v8::CTypeInfo* rcgetpclabel = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infogetpclabel = new v8::CFunctionInfo(*rcgetpclabel, 3, cargsgetpclabel);
  v8::CFunction* pFgetpclabel = new v8::CFunction((const void*)&getpclabelFast, infogetpclabel);
  SET_FAST_METHOD(isolate, module, "getpclabel", pFgetpclabel, getpclabelSlow);

  SET_MODULE(isolate, target, "dynasm", module);
}
} // namespace dynasm
} // namespace spin

extern "C" {
  void* _register_dynasm() {
    return (void*)spin::dynasm::Init;
  }
}
