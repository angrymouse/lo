
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
extern "C" {
#include <wireguard.h>
}
#include <spin.h>

namespace spin {
namespace wireguard {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;



void setSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  wg_device* v0 = reinterpret_cast<wg_device*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = wg_set_device(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t setFast(void* p, void* p0) {
  wg_device* v0 = reinterpret_cast<wg_device*>(p0);
  return wg_set_device(v0);
}
void getSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  wg_device** v0 = reinterpret_cast<wg_device**>(args[0].As<Uint8Array>()->Buffer()->Data());
  String::Utf8Value v1(isolate, args[1]);
  int32_t rc = wg_get_device(v0, *v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t getFast(void* p, struct FastApiTypedArray* const p0, struct FastOneByteString* const p1) {
  wg_device** v0 = reinterpret_cast<wg_device**>(p0->data);
  struct FastOneByteString* const v1 = p1;
  return wg_get_device(v0, v1->data);
}
void addSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = wg_add_device(*v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t addFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return wg_add_device(v0->data);
}
void deleteSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = wg_del_device(*v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t deleteFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return wg_del_device(v0->data);
}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  wg_device* v0 = reinterpret_cast<wg_device*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  wg_free_device(v0);
}

void freeFast(void* p, void* p0) {
  wg_device* v0 = reinterpret_cast<wg_device*>(p0);
  wg_free_device(v0);
}
void listSlow(const FunctionCallbackInfo<Value> &args) {

  const char* rc = wg_list_device_names();
  Local<ArrayBuffer> ab = args[0].As<Uint32Array>()->Buffer();
  ((const char**)ab->Data())[0] = rc;
}

void listFast(void* p, struct FastApiTypedArray* const p_ret) {

  const char* r = wg_list_device_names();
  ((const char**)p_ret->data)[0] = r;

}
void genpubKeySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u8 = args[0].As<Uint8Array>();
  uint8_t* ptr = (uint8_t*)u8->Buffer()->Data() + u8->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr);
  const wg_key* v1 = reinterpret_cast<const wg_key*>(args[1].As<Uint8Array>()->Buffer()->Data());
  wg_generate_public_key(*v0, *v1);
}

void genpubKeyFast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  const wg_key* v1 = reinterpret_cast<const wg_key*>(p1->data);
  wg_generate_public_key(*v0, *v1);
}
void genprivKeySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u8 = args[0].As<Uint8Array>();
  uint8_t* ptr = (uint8_t*)u8->Buffer()->Data() + u8->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr);
  wg_generate_private_key(*v0);
}

void genprivKeyFast(void* p, struct FastApiTypedArray* const p0) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  wg_generate_private_key(*v0);
}
void genpresharedKeySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u8 = args[0].As<Uint8Array>();
  uint8_t* ptr = (uint8_t*)u8->Buffer()->Data() + u8->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr);
  wg_generate_preshared_key(*v0);
}

void genpresharedKeyFast(void* p, struct FastApiTypedArray* const p0) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  wg_generate_preshared_key(*v0);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);

  v8::CTypeInfo* cargsset = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsset[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsset[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcset = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoset = new v8::CFunctionInfo(*rcset, 2, cargsset);
  v8::CFunction* pFset = new v8::CFunction((const void*)&setFast, infoset);
  SET_FAST_METHOD(isolate, module, "set", pFset, setSlow);

  v8::CTypeInfo* cargsget = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsget[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsget[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsget[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString);
  v8::CTypeInfo* rcget = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoget = new v8::CFunctionInfo(*rcget, 3, cargsget);
  v8::CFunction* pFget = new v8::CFunction((const void*)&getFast, infoget);
  SET_FAST_METHOD(isolate, module, "get", pFget, getSlow);

  v8::CTypeInfo* cargsadd = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsadd[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsadd[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString);
  v8::CTypeInfo* rcadd = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoadd = new v8::CFunctionInfo(*rcadd, 2, cargsadd);
  v8::CFunction* pFadd = new v8::CFunction((const void*)&addFast, infoadd);
  SET_FAST_METHOD(isolate, module, "add", pFadd, addSlow);

  v8::CTypeInfo* cargsdelete = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsdelete[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsdelete[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString);
  v8::CTypeInfo* rcdelete = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infodelete = new v8::CFunctionInfo(*rcdelete, 2, cargsdelete);
  v8::CFunction* pFdelete = new v8::CFunction((const void*)&deleteFast, infodelete);
  SET_FAST_METHOD(isolate, module, "delete", pFdelete, deleteSlow);

  v8::CTypeInfo* cargsfree = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsfree[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsfree[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcfree = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infofree = new v8::CFunctionInfo(*rcfree, 2, cargsfree);
  v8::CFunction* pFfree = new v8::CFunction((const void*)&freeFast, infofree);
  SET_FAST_METHOD(isolate, module, "free", pFfree, freeSlow);
  v8::CTypeInfo* cargslist = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargslist[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);

  cargslist[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rclist = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infolist = new v8::CFunctionInfo(*rclist, 2, cargslist);
  v8::CFunction* pFlist = new v8::CFunction((const void*)&listFast, infolist);
  SET_FAST_METHOD(isolate, module, "list", pFlist, listSlow);

  v8::CTypeInfo* cargsgenpubKey = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsgenpubKey[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsgenpubKey[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsgenpubKey[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcgenpubKey = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infogenpubKey = new v8::CFunctionInfo(*rcgenpubKey, 3, cargsgenpubKey);
  v8::CFunction* pFgenpubKey = new v8::CFunction((const void*)&genpubKeyFast, infogenpubKey);
  SET_FAST_METHOD(isolate, module, "genpubKey", pFgenpubKey, genpubKeySlow);

  v8::CTypeInfo* cargsgenprivKey = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsgenprivKey[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsgenprivKey[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcgenprivKey = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infogenprivKey = new v8::CFunctionInfo(*rcgenprivKey, 2, cargsgenprivKey);
  v8::CFunction* pFgenprivKey = new v8::CFunction((const void*)&genprivKeyFast, infogenprivKey);
  SET_FAST_METHOD(isolate, module, "genprivKey", pFgenprivKey, genprivKeySlow);

  v8::CTypeInfo* cargsgenpresharedKey = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsgenpresharedKey[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsgenpresharedKey[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcgenpresharedKey = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infogenpresharedKey = new v8::CFunctionInfo(*rcgenpresharedKey, 2, cargsgenpresharedKey);
  v8::CFunction* pFgenpresharedKey = new v8::CFunction((const void*)&genpresharedKeyFast, infogenpresharedKey);
  SET_FAST_METHOD(isolate, module, "genpresharedKey", pFgenpresharedKey, genpresharedKeySlow);

  SET_MODULE(isolate, target, "wireguard", module);
}
} // namespace wireguard
} // namespace spin

extern "C" {
  void* _register_wireguard() {
    return (void*)spin::wireguard::Init;
  }
}
