
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <wireguard.h>
#include <spin.h>

namespace spin {
namespace wireguard {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;



int32_t setFast(void* p, void* p0);
v8::CTypeInfo cargsset[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcset = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoset = v8::CFunctionInfo(rcset, 2, cargsset);
v8::CFunction pFset = v8::CFunction((const void*)&setFast, &infoset);

int32_t getFast(void* p, struct FastApiTypedArray* const p0, struct FastOneByteString* const p1);
v8::CTypeInfo cargsget[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcget = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoget = v8::CFunctionInfo(rcget, 3, cargsget);
v8::CFunction pFget = v8::CFunction((const void*)&getFast, &infoget);

int32_t addFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsadd[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcadd = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoadd = v8::CFunctionInfo(rcadd, 2, cargsadd);
v8::CFunction pFadd = v8::CFunction((const void*)&addFast, &infoadd);

int32_t deleteFast(void* p, struct FastOneByteString* const p0);
v8::CTypeInfo cargsdelete[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kSeqOneByteString),
};
v8::CTypeInfo rcdelete = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infodelete = v8::CFunctionInfo(rcdelete, 2, cargsdelete);
v8::CFunction pFdelete = v8::CFunction((const void*)&deleteFast, &infodelete);

void freeFast(void* p, void* p0);
v8::CTypeInfo cargsfree[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcfree = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infofree = v8::CFunctionInfo(rcfree, 2, cargsfree);
v8::CFunction pFfree = v8::CFunction((const void*)&freeFast, &infofree);

void listFast(void* p, struct FastApiTypedArray* const p_ret);
v8::CTypeInfo cargslist[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),

  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone)
};
v8::CTypeInfo rclist = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infolist = v8::CFunctionInfo(rclist, 2, cargslist);
v8::CFunction pFlist = v8::CFunction((const void*)&listFast, &infolist);

void keytobase64Fast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargskeytobase64[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rckeytobase64 = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infokeytobase64 = v8::CFunctionInfo(rckeytobase64, 3, cargskeytobase64);
v8::CFunction pFkeytobase64 = v8::CFunction((const void*)&keytobase64Fast, &infokeytobase64);

int32_t keyfrombase64Fast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargskeyfrombase64[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rckeyfrombase64 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infokeyfrombase64 = v8::CFunctionInfo(rckeyfrombase64, 3, cargskeyfrombase64);
v8::CFunction pFkeyfrombase64 = v8::CFunction((const void*)&keyfrombase64Fast, &infokeyfrombase64);

void genpubKeyFast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1);
v8::CTypeInfo cargsgenpubKey[3] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcgenpubKey = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogenpubKey = v8::CFunctionInfo(rcgenpubKey, 3, cargsgenpubKey);
v8::CFunction pFgenpubKey = v8::CFunction((const void*)&genpubKeyFast, &infogenpubKey);

void genprivKeyFast(void* p, struct FastApiTypedArray* const p0);
v8::CTypeInfo cargsgenprivKey[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcgenprivKey = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogenprivKey = v8::CFunctionInfo(rcgenprivKey, 2, cargsgenprivKey);
v8::CFunction pFgenprivKey = v8::CFunction((const void*)&genprivKeyFast, &infogenprivKey);

void genpresharedKeyFast(void* p, struct FastApiTypedArray* const p0);
v8::CTypeInfo cargsgenpresharedKey[2] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcgenpresharedKey = v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
v8::CFunctionInfo infogenpresharedKey = v8::CFunctionInfo(rcgenpresharedKey, 2, cargsgenpresharedKey);
v8::CFunction pFgenpresharedKey = v8::CFunction((const void*)&genpresharedKeyFast, &infogenpresharedKey);



void setSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  wg_device* v0 = reinterpret_cast<wg_device*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  int32_t rc = wg_set_device(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t setFast(void* p, void* p0) {
  wg_device* v0 = reinterpret_cast<wg_device*>(p0);
  return wg_set_device(v0);
}
void getSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint32Array> u320 = args[0].As<Uint32Array>();
  uint8_t* ptr0 = (uint8_t*)u320->Buffer()->Data() + u320->ByteOffset();
  wg_device** v0 = reinterpret_cast<wg_device**>(ptr0);
  String::Utf8Value v1(isolate, args[1]);
  int32_t rc = wg_get_device(v0, *v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t getFast(void* p, struct FastApiTypedArray* const p0, struct FastOneByteString* const p1) {
  wg_device** v0 = reinterpret_cast<wg_device**>(p0->data);
  struct FastOneByteString* const v1 = p1;
  return wg_get_device(v0, v1->data);
}
void addSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = wg_add_device(*v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t addFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return wg_add_device(v0->data);
}
void deleteSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  String::Utf8Value v0(isolate, args[0]);
  int32_t rc = wg_del_device(*v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t deleteFast(void* p, struct FastOneByteString* const p0) {
  struct FastOneByteString* const v0 = p0;
  return wg_del_device(v0->data);
}
void freeSlow(const FunctionCallbackInfo<Value> &args) {
  wg_device* v0 = reinterpret_cast<wg_device*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  wg_free_device(v0);
}

void freeFast(void* p, void* p0) {
  wg_device* v0 = reinterpret_cast<wg_device*>(p0);
  wg_free_device(v0);
}
void listSlow(const FunctionCallbackInfo<Value> &args) {

  const char* rc = wg_list_device_names();
  Local<ArrayBuffer> ab = args[0].As<Uint32Array>()->Buffer();
  ((const char**)ab->Data())[0] = rc;
}

void listFast(void* p, struct FastApiTypedArray* const p_ret) {

  const char* r = wg_list_device_names();
  ((const char**)p_ret->data)[0] = r;

}
void keytobase64Slow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  wg_key_b64_string* v0 = reinterpret_cast<wg_key_b64_string*>(ptr0);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  const wg_key* v1 = reinterpret_cast<const wg_key*>(ptr1);
  wg_key_to_base64(*v0, *v1);
}

void keytobase64Fast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1) {
  wg_key_b64_string* v0 = reinterpret_cast<wg_key_b64_string*>(p0->data);
  const wg_key* v1 = reinterpret_cast<const wg_key*>(p1->data);
  wg_key_to_base64(*v0, *v1);
}
void keyfrombase64Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr0);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  const wg_key_b64_string* v1 = reinterpret_cast<const wg_key_b64_string*>(ptr1);
  int32_t rc = wg_key_from_base64(*v0, *v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t keyfrombase64Fast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  const wg_key_b64_string* v1 = reinterpret_cast<const wg_key_b64_string*>(p1->data);
  return wg_key_from_base64(*v0, *v1);
}
void genpubKeySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr0);
  Local<Uint8Array> u81 = args[1].As<Uint8Array>();
  uint8_t* ptr1 = (uint8_t*)u81->Buffer()->Data() + u81->ByteOffset();
  const wg_key* v1 = reinterpret_cast<const wg_key*>(ptr1);
  wg_generate_public_key(*v0, *v1);
}

void genpubKeyFast(void* p, struct FastApiTypedArray* const p0, struct FastApiTypedArray* const p1) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  const wg_key* v1 = reinterpret_cast<const wg_key*>(p1->data);
  wg_generate_public_key(*v0, *v1);
}
void genprivKeySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr0);
  wg_generate_private_key(*v0);
}

void genprivKeyFast(void* p, struct FastApiTypedArray* const p0) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  wg_generate_private_key(*v0);
}
void genpresharedKeySlow(const FunctionCallbackInfo<Value> &args) {
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  wg_key* v0 = reinterpret_cast<wg_key*>(ptr0);
  wg_generate_preshared_key(*v0);
}

void genpresharedKeyFast(void* p, struct FastApiTypedArray* const p0) {
  wg_key* v0 = reinterpret_cast<wg_key*>(p0->data);
  wg_generate_preshared_key(*v0);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "set", &pFset, setSlow);
  SET_FAST_METHOD(isolate, module, "get", &pFget, getSlow);
  SET_FAST_METHOD(isolate, module, "add", &pFadd, addSlow);
  SET_FAST_METHOD(isolate, module, "delete", &pFdelete, deleteSlow);
  SET_FAST_METHOD(isolate, module, "free", &pFfree, freeSlow);
  SET_FAST_METHOD(isolate, module, "list", &pFlist, listSlow);
  SET_FAST_METHOD(isolate, module, "keytobase64", &pFkeytobase64, keytobase64Slow);
  SET_FAST_METHOD(isolate, module, "keyfrombase64", &pFkeyfrombase64, keyfrombase64Slow);
  SET_FAST_METHOD(isolate, module, "genpubKey", &pFgenpubKey, genpubKeySlow);
  SET_FAST_METHOD(isolate, module, "genprivKey", &pFgenprivKey, genprivKeySlow);
  SET_FAST_METHOD(isolate, module, "genpresharedKey", &pFgenpresharedKey, genpresharedKeySlow);

  SET_MODULE(isolate, target, "wireguard", module);
}
} // namespace wireguard
} // namespace spin

extern "C" {
  void* _register_wireguard() {
    return (void*)spin::wireguard::Init;
  }
}
