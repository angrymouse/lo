
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <sqlite3.h>
#include <spin.h>

namespace spin {
namespace sqlite {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;

typedef int (*callback)(void*,int,char**,char**);


void versionSlow(const FunctionCallbackInfo<Value> &args) {

  const char* rc = sqlite3_libversion();
  Local<ArrayBuffer> ab = args[0].As<Uint32Array>()->Buffer();
  ((const char**)ab->Data())[0] = rc;
}

void versionFast(void* p, struct FastApiTypedArray* const p_ret) {

  const char* r = sqlite3_libversion();
  ((const char**)p_ret->data)[0] = r;

}
void openSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  const char* v0 = reinterpret_cast<const char*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  sqlite3 ** v1 = reinterpret_cast<sqlite3 **>((uint64_t)args[1]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_open(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t openFast(void* p, void* p0, void* p1) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  sqlite3 ** v1 = reinterpret_cast<sqlite3 **>(p1);
  return sqlite3_open(v0, v1);
}
void open2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  const char* v0 = reinterpret_cast<const char*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  sqlite3 ** v1 = reinterpret_cast<sqlite3 **>((uint64_t)args[1]->NumberValue(context).ToChecked());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  const char* v3 = reinterpret_cast<const char*>((uint64_t)args[3]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_open_v2(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t open2Fast(void* p, void* p0, void* p1, int32_t p2, void* p3) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  sqlite3 ** v1 = reinterpret_cast<sqlite3 **>(p1);
  int32_t v2 = p2;
  const char* v3 = reinterpret_cast<const char*>(p3);
  return sqlite3_open_v2(v0, v1, v2, v3);
}
void execSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3* v0 = reinterpret_cast<sqlite3*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  const char* v1 = reinterpret_cast<const char*>((uint64_t)args[1]->NumberValue(context).ToChecked());
  callback v2 = reinterpret_cast<callback>((uint64_t)args[2]->NumberValue(context).ToChecked());
  void* v3 = reinterpret_cast<void*>((uint64_t)args[3]->NumberValue(context).ToChecked());
  char** v4 = reinterpret_cast<char**>((uint64_t)args[4]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_exec(v0, v1, v2, v3, v4);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t execFast(void* p, void* p0, void* p1, void* p2, void* p3, void* p4) {
  sqlite3* v0 = reinterpret_cast<sqlite3*>(p0);
  const char* v1 = reinterpret_cast<const char*>(p1);
  callback v2 = reinterpret_cast<callback>(p2);
  void* v3 = reinterpret_cast<void*>(p3);
  char** v4 = reinterpret_cast<char**>(p4);
  return sqlite3_exec(v0, v1, v2, v3, v4);
}
void errmsgSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3* v0 = reinterpret_cast<sqlite3*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  const char* rc = sqlite3_errmsg(v0);
  Local<ArrayBuffer> ab = args[1].As<Uint32Array>()->Buffer();
  ((const char**)ab->Data())[0] = rc;
}

void errmsgFast(void* p, void* p0, struct FastApiTypedArray* const p_ret) {
  sqlite3* v0 = reinterpret_cast<sqlite3*>(p0);
  const char* r = sqlite3_errmsg(v0);
  ((const char**)p_ret->data)[0] = r;

}
void close2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3* v0 = reinterpret_cast<sqlite3*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_close_v2(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t close2Fast(void* p, void* p0) {
  sqlite3* v0 = reinterpret_cast<sqlite3*>(p0);
  return sqlite3_close_v2(v0);
}
void prepare2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3* v0 = reinterpret_cast<sqlite3*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  const char* v1 = reinterpret_cast<const char*>((uint64_t)args[1]->NumberValue(context).ToChecked());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  sqlite3_stmt ** v3 = reinterpret_cast<sqlite3_stmt **>((uint64_t)args[3]->NumberValue(context).ToChecked());
  const char** v4 = reinterpret_cast<const char**>((uint64_t)args[4]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_prepare_v2(v0, v1, v2, v3, v4);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t prepare2Fast(void* p, void* p0, void* p1, int32_t p2, void* p3, void* p4) {
  sqlite3* v0 = reinterpret_cast<sqlite3*>(p0);
  const char* v1 = reinterpret_cast<const char*>(p1);
  int32_t v2 = p2;
  sqlite3_stmt ** v3 = reinterpret_cast<sqlite3_stmt **>(p3);
  const char** v4 = reinterpret_cast<const char**>(p4);
  return sqlite3_prepare_v2(v0, v1, v2, v3, v4);
}
void finalizeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_finalize(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t finalizeFast(void* p, void* p0) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  return sqlite3_finalize(v0);
}
void column_countSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_column_count(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t column_countFast(void* p, void* p0) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  return sqlite3_column_count(v0);
}
void column_typeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = sqlite3_column_type(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t column_typeFast(void* p, void* p0, int32_t p1) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  int32_t v1 = p1;
  return sqlite3_column_type(v0, v1);
}
void column_nameSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  const char* rc = sqlite3_column_name(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((const char**)ab->Data())[0] = rc;
}

void column_nameFast(void* p, void* p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  int32_t v1 = p1;
  const char* r = sqlite3_column_name(v0, v1);
  ((const char**)p_ret->data)[0] = r;

}
void stepSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_step(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t stepFast(void* p, void* p0) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  return sqlite3_step(v0);
}
void resetSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t rc = sqlite3_reset(v0);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t resetFast(void* p, void* p0) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  return sqlite3_reset(v0);
}
void column_intSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = sqlite3_column_int(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t column_intFast(void* p, void* p0, int32_t p1) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  int32_t v1 = p1;
  return sqlite3_column_int(v0, v1);
}
void column_doubleSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  float rc = sqlite3_column_double(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

float column_doubleFast(void* p, void* p0, int32_t p1) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  int32_t v1 = p1;
  return sqlite3_column_double(v0, v1);
}
void column_textSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  const unsigned char* rc = sqlite3_column_text(v0, v1);
  Local<ArrayBuffer> ab = args[2].As<Uint32Array>()->Buffer();
  ((const unsigned char**)ab->Data())[0] = rc;
}

void column_textFast(void* p, void* p0, int32_t p1, struct FastApiTypedArray* const p_ret) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  int32_t v1 = p1;
  const unsigned char* r = sqlite3_column_text(v0, v1);
  ((const unsigned char**)p_ret->data)[0] = r;

}
void column_bytesSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();

  Local<Context> context = isolate->GetCurrentContext();
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>((uint64_t)args[0]->NumberValue(context).ToChecked());
  int32_t v1 = Local<Integer>::Cast(args[1])->Value();
  int32_t rc = sqlite3_column_bytes(v0, v1);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t column_bytesFast(void* p, void* p0, int32_t p1) {
  sqlite3_stmt* v0 = reinterpret_cast<sqlite3_stmt*>(p0);
  int32_t v1 = p1;
  return sqlite3_column_bytes(v0, v1);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  v8::CTypeInfo* cargsversion = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsversion[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);

  cargsversion[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcversion = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infoversion = new v8::CFunctionInfo(*rcversion, 2, cargsversion);
  v8::CFunction* pFversion = new v8::CFunction((const void*)&versionFast, infoversion);
  SET_FAST_METHOD(isolate, module, "version", pFversion, versionSlow);

  v8::CTypeInfo* cargsopen = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargsopen[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsopen[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsopen[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcopen = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoopen = new v8::CFunctionInfo(*rcopen, 3, cargsopen);
  v8::CFunction* pFopen = new v8::CFunction((const void*)&openFast, infoopen);
  SET_FAST_METHOD(isolate, module, "open", pFopen, openSlow);

  v8::CTypeInfo* cargsopen2 = (v8::CTypeInfo*)calloc(5, sizeof(v8::CTypeInfo));
  cargsopen2[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsopen2[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsopen2[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsopen2[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  cargsopen2[4] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcopen2 = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoopen2 = new v8::CFunctionInfo(*rcopen2, 5, cargsopen2);
  v8::CFunction* pFopen2 = new v8::CFunction((const void*)&open2Fast, infoopen2);
  SET_FAST_METHOD(isolate, module, "open2", pFopen2, open2Slow);

  v8::CTypeInfo* cargsexec = (v8::CTypeInfo*)calloc(6, sizeof(v8::CTypeInfo));
  cargsexec[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsexec[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsexec[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsexec[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsexec[4] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsexec[5] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcexec = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoexec = new v8::CFunctionInfo(*rcexec, 6, cargsexec);
  v8::CFunction* pFexec = new v8::CFunction((const void*)&execFast, infoexec);
  SET_FAST_METHOD(isolate, module, "exec", pFexec, execSlow);
  v8::CTypeInfo* cargserrmsg = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargserrmsg[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargserrmsg[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargserrmsg[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcerrmsg = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infoerrmsg = new v8::CFunctionInfo(*rcerrmsg, 3, cargserrmsg);
  v8::CFunction* pFerrmsg = new v8::CFunction((const void*)&errmsgFast, infoerrmsg);
  SET_FAST_METHOD(isolate, module, "errmsg", pFerrmsg, errmsgSlow);

  v8::CTypeInfo* cargsclose2 = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsclose2[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsclose2[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcclose2 = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoclose2 = new v8::CFunctionInfo(*rcclose2, 2, cargsclose2);
  v8::CFunction* pFclose2 = new v8::CFunction((const void*)&close2Fast, infoclose2);
  SET_FAST_METHOD(isolate, module, "close2", pFclose2, close2Slow);

  v8::CTypeInfo* cargsprepare2 = (v8::CTypeInfo*)calloc(6, sizeof(v8::CTypeInfo));
  cargsprepare2[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsprepare2[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsprepare2[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsprepare2[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  cargsprepare2[4] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsprepare2[5] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcprepare2 = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoprepare2 = new v8::CFunctionInfo(*rcprepare2, 6, cargsprepare2);
  v8::CFunction* pFprepare2 = new v8::CFunction((const void*)&prepare2Fast, infoprepare2);
  SET_FAST_METHOD(isolate, module, "prepare2", pFprepare2, prepare2Slow);

  v8::CTypeInfo* cargsfinalize = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsfinalize[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsfinalize[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcfinalize = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infofinalize = new v8::CFunctionInfo(*rcfinalize, 2, cargsfinalize);
  v8::CFunction* pFfinalize = new v8::CFunction((const void*)&finalizeFast, infofinalize);
  SET_FAST_METHOD(isolate, module, "finalize", pFfinalize, finalizeSlow);

  v8::CTypeInfo* cargscolumn_count = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargscolumn_count[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_count[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rccolumn_count = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infocolumn_count = new v8::CFunctionInfo(*rccolumn_count, 2, cargscolumn_count);
  v8::CFunction* pFcolumn_count = new v8::CFunction((const void*)&column_countFast, infocolumn_count);
  SET_FAST_METHOD(isolate, module, "column_count", pFcolumn_count, column_countSlow);

  v8::CTypeInfo* cargscolumn_type = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargscolumn_type[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_type[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargscolumn_type[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CTypeInfo* rccolumn_type = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infocolumn_type = new v8::CFunctionInfo(*rccolumn_type, 3, cargscolumn_type);
  v8::CFunction* pFcolumn_type = new v8::CFunction((const void*)&column_typeFast, infocolumn_type);
  SET_FAST_METHOD(isolate, module, "column_type", pFcolumn_type, column_typeSlow);
  v8::CTypeInfo* cargscolumn_name = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargscolumn_name[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_name[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargscolumn_name[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  cargscolumn_name[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rccolumn_name = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infocolumn_name = new v8::CFunctionInfo(*rccolumn_name, 4, cargscolumn_name);
  v8::CFunction* pFcolumn_name = new v8::CFunction((const void*)&column_nameFast, infocolumn_name);
  SET_FAST_METHOD(isolate, module, "column_name", pFcolumn_name, column_nameSlow);

  v8::CTypeInfo* cargsstep = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsstep[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsstep[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcstep = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infostep = new v8::CFunctionInfo(*rcstep, 2, cargsstep);
  v8::CFunction* pFstep = new v8::CFunction((const void*)&stepFast, infostep);
  SET_FAST_METHOD(isolate, module, "step", pFstep, stepSlow);

  v8::CTypeInfo* cargsreset = (v8::CTypeInfo*)calloc(2, sizeof(v8::CTypeInfo));
  cargsreset[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsreset[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcreset = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* inforeset = new v8::CFunctionInfo(*rcreset, 2, cargsreset);
  v8::CFunction* pFreset = new v8::CFunction((const void*)&resetFast, inforeset);
  SET_FAST_METHOD(isolate, module, "reset", pFreset, resetSlow);

  v8::CTypeInfo* cargscolumn_int = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargscolumn_int[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_int[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargscolumn_int[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CTypeInfo* rccolumn_int = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infocolumn_int = new v8::CFunctionInfo(*rccolumn_int, 3, cargscolumn_int);
  v8::CFunction* pFcolumn_int = new v8::CFunction((const void*)&column_intFast, infocolumn_int);
  SET_FAST_METHOD(isolate, module, "column_int", pFcolumn_int, column_intSlow);

  v8::CTypeInfo* cargscolumn_double = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargscolumn_double[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_double[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargscolumn_double[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CTypeInfo* rccolumn_double = new v8::CTypeInfo(v8::CTypeInfo::Type::kFloat32);
  v8::CFunctionInfo* infocolumn_double = new v8::CFunctionInfo(*rccolumn_double, 3, cargscolumn_double);
  v8::CFunction* pFcolumn_double = new v8::CFunction((const void*)&column_doubleFast, infocolumn_double);
  SET_FAST_METHOD(isolate, module, "column_double", pFcolumn_double, column_doubleSlow);
  v8::CTypeInfo* cargscolumn_text = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargscolumn_text[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_text[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargscolumn_text[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  cargscolumn_text[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32, v8::CTypeInfo::SequenceType::kIsTypedArray, v8::CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rccolumn_text = new v8::CTypeInfo(v8::CTypeInfo::Type::kVoid);
  v8::CFunctionInfo* infocolumn_text = new v8::CFunctionInfo(*rccolumn_text, 4, cargscolumn_text);
  v8::CFunction* pFcolumn_text = new v8::CFunction((const void*)&column_textFast, infocolumn_text);
  SET_FAST_METHOD(isolate, module, "column_text", pFcolumn_text, column_textSlow);

  v8::CTypeInfo* cargscolumn_bytes = (v8::CTypeInfo*)calloc(3, sizeof(v8::CTypeInfo));
  cargscolumn_bytes[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargscolumn_bytes[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargscolumn_bytes[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CTypeInfo* rccolumn_bytes = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infocolumn_bytes = new v8::CFunctionInfo(*rccolumn_bytes, 3, cargscolumn_bytes);
  v8::CFunction* pFcolumn_bytes = new v8::CFunction((const void*)&column_bytesFast, infocolumn_bytes);
  SET_FAST_METHOD(isolate, module, "column_bytes", pFcolumn_bytes, column_bytesSlow);

  SET_MODULE(isolate, target, "sqlite", module);
}
} // namespace sqlite
} // namespace spin

extern "C" {
  void* _register_sqlite() {
    return (void*)spin::sqlite::Init;
  }
}
