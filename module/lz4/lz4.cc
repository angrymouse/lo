
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <liblz4.h>
#include <spin.h>

namespace spin {
namespace lz4 {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;
using v8::BigInt;



int32_t compress_defaultFast(void* p, void* p0, void* p1, int32_t p2, int32_t p3);
v8::CTypeInfo cargscompress_default[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rccompress_default = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infocompress_default = v8::CFunctionInfo(rccompress_default, 5, cargscompress_default);
v8::CFunction pFcompress_default = v8::CFunction((const void*)&compress_defaultFast, &infocompress_default);

int32_t compress_hcFast(void* p, void* p0, void* p1, int32_t p2, int32_t p3, int32_t p4);
v8::CTypeInfo cargscompress_hc[6] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rccompress_hc = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infocompress_hc = v8::CFunctionInfo(rccompress_hc, 6, cargscompress_hc);
v8::CFunction pFcompress_hc = v8::CFunction((const void*)&compress_hcFast, &infocompress_hc);

int32_t decompress_safeFast(void* p, void* p0, void* p1, int32_t p2, int32_t p3);
v8::CTypeInfo cargsdecompress_safe[5] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kInt32),
};
v8::CTypeInfo rcdecompress_safe = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infodecompress_safe = v8::CFunctionInfo(rcdecompress_safe, 5, cargsdecompress_safe);
v8::CFunction pFdecompress_safe = v8::CFunction((const void*)&decompress_safeFast, &infodecompress_safe);



void compress_defaultSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  const char* v0 = reinterpret_cast<const char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  char* v1 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = LZ4_compress_default(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t compress_defaultFast(void* p, void* p0, void* p1, int32_t p2, int32_t p3) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  char* v1 = reinterpret_cast<char*>(p1);
  int32_t v2 = p2;
  int32_t v3 = p3;
  return LZ4_compress_default(v0, v1, v2, v3);
}
void compress_hcSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  const char* v0 = reinterpret_cast<const char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  char* v1 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t v4 = Local<Integer>::Cast(args[4])->Value();
  int32_t rc = LZ4_compress_HC(v0, v1, v2, v3, v4);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t compress_hcFast(void* p, void* p0, void* p1, int32_t p2, int32_t p3, int32_t p4) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  char* v1 = reinterpret_cast<char*>(p1);
  int32_t v2 = p2;
  int32_t v3 = p3;
  int32_t v4 = p4;
  return LZ4_compress_HC(v0, v1, v2, v3, v4);
}
void decompress_safeSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  const char* v0 = reinterpret_cast<const char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  char* v1 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[1])->Value());
  int32_t v2 = Local<Integer>::Cast(args[2])->Value();
  int32_t v3 = Local<Integer>::Cast(args[3])->Value();
  int32_t rc = LZ4_decompress_safe(v0, v1, v2, v3);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t decompress_safeFast(void* p, void* p0, void* p1, int32_t p2, int32_t p3) {
  const char* v0 = reinterpret_cast<const char*>(p0);
  char* v1 = reinterpret_cast<char*>(p1);
  int32_t v2 = p2;
  int32_t v3 = p3;
  return LZ4_decompress_safe(v0, v1, v2, v3);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "compress_default", &pFcompress_default, compress_defaultSlow);
  SET_FAST_METHOD(isolate, module, "compress_hc", &pFcompress_hc, compress_hcSlow);
  SET_FAST_METHOD(isolate, module, "decompress_safe", &pFdecompress_safe, decompress_safeSlow);


  SET_MODULE(isolate, target, "lz4", module);
}
} // namespace lz4
} // namespace spin

extern "C" {
  void* _register_lz4() {
    return (void*)spin::lz4::Init;
  }
}
