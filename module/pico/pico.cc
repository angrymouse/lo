
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <pico.h>
#include <spin.h>

namespace spin {
namespace pico {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;



void parseRequestSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  char* v0 = reinterpret_cast<char*>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  httpRequest* v2 = reinterpret_cast<httpRequest*>(ptr2);
  int32_t rc = parse_request(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseRequestFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2) {
  char* v0 = reinterpret_cast<char*>(p0->data);
  uint32_t v1 = p1;
  httpRequest* v2 = reinterpret_cast<httpRequest*>(p2->data);
  return parse_request(v0, v1, v2);
}
void parseRequest2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  httpRequest* v2 = reinterpret_cast<httpRequest*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = parse_request(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseRequest2Fast(void* p, void* p0, uint32_t p1, void* p2) {
  char* v0 = reinterpret_cast<char*>(p0);
  uint32_t v1 = p1;
  httpRequest* v2 = reinterpret_cast<httpRequest*>(p2);
  return parse_request(v0, v1, v2);
}
void parseResponseSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  char* v0 = reinterpret_cast<char*>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  httpResponse* v2 = reinterpret_cast<httpResponse*>(ptr2);
  int32_t rc = parse_response(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseResponseFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2) {
  char* v0 = reinterpret_cast<char*>(p0->data);
  uint32_t v1 = p1;
  httpResponse* v2 = reinterpret_cast<httpResponse*>(p2->data);
  return parse_response(v0, v1, v2);
}
void parseResponse2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  httpResponse* v2 = reinterpret_cast<httpResponse*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = parse_response(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseResponse2Fast(void* p, void* p0, uint32_t p1, void* p2) {
  char* v0 = reinterpret_cast<char*>(p0);
  uint32_t v1 = p1;
  httpResponse* v2 = reinterpret_cast<httpResponse*>(p2);
  return parse_response(v0, v1, v2);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);

  v8::CTypeInfo* cargsparseRequest = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargsparseRequest[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsparseRequest[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsparseRequest[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsparseRequest[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcparseRequest = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoparseRequest = new v8::CFunctionInfo(*rcparseRequest, 4, cargsparseRequest);
  v8::CFunction* pFparseRequest = new v8::CFunction((const void*)&parseRequestFast, infoparseRequest);
  SET_FAST_METHOD(isolate, module, "parseRequest", pFparseRequest, parseRequestSlow);

  v8::CTypeInfo* cargsparseRequest2 = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargsparseRequest2[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsparseRequest2[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsparseRequest2[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsparseRequest2[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcparseRequest2 = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoparseRequest2 = new v8::CFunctionInfo(*rcparseRequest2, 4, cargsparseRequest2);
  v8::CFunction* pFparseRequest2 = new v8::CFunction((const void*)&parseRequest2Fast, infoparseRequest2);
  SET_FAST_METHOD(isolate, module, "parseRequest2", pFparseRequest2, parseRequest2Slow);

  v8::CTypeInfo* cargsparseResponse = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargsparseResponse[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsparseResponse[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  cargsparseResponse[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsparseResponse[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone);
  v8::CTypeInfo* rcparseResponse = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoparseResponse = new v8::CFunctionInfo(*rcparseResponse, 4, cargsparseResponse);
  v8::CFunction* pFparseResponse = new v8::CFunction((const void*)&parseResponseFast, infoparseResponse);
  SET_FAST_METHOD(isolate, module, "parseResponse", pFparseResponse, parseResponseSlow);

  v8::CTypeInfo* cargsparseResponse2 = (v8::CTypeInfo*)calloc(4, sizeof(v8::CTypeInfo));
  cargsparseResponse2[0] = v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value);
  cargsparseResponse2[1] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  cargsparseResponse2[2] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint32);
  cargsparseResponse2[3] = v8::CTypeInfo(v8::CTypeInfo::Type::kUint64);
  v8::CTypeInfo* rcparseResponse2 = new v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
  v8::CFunctionInfo* infoparseResponse2 = new v8::CFunctionInfo(*rcparseResponse2, 4, cargsparseResponse2);
  v8::CFunction* pFparseResponse2 = new v8::CFunction((const void*)&parseResponse2Fast, infoparseResponse2);
  SET_FAST_METHOD(isolate, module, "parseResponse2", pFparseResponse2, parseResponse2Slow);

  SET_MODULE(isolate, target, "pico", module);
}
} // namespace pico
} // namespace spin

extern "C" {
  void* _register_pico() {
    return (void*)spin::pico::Init;
  }
}
