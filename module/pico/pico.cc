
// [do not edit,<auto-generated />]
// This file has been automatically generated, please do not change unless you disable auto-generation in the Makefile  
#include <picohttpparser.h>
#include <spin.h>

namespace spin {
namespace pico {

using v8::String;
using v8::FunctionCallbackInfo;
using v8::Array;
using v8::Local;
using v8::ObjectTemplate;
using v8::Isolate;
using v8::Value;
using v8::Uint32Array;
using v8::ArrayBuffer;
using v8::Context;
using v8::Integer;
using v8::Function;
using v8::NewStringType;
using v8::Object;
using v8::BackingStore;
using v8::TryCatch;
using v8::ScriptCompiler;
using v8::Module;
using v8::FixedArray;
using v8::ScriptOrigin;
using v8::SharedArrayBuffer;
using v8::MaybeLocal;
using v8::HandleScope;
using v8::Promise;
using v8::Number;
using v8::StackTrace;
using v8::Message;
using v8::StackFrame;
using v8::Maybe;
using v8::FunctionTemplate;
using v8::FunctionCallback;
using v8::PromiseRejectMessage;
using v8::CFunction;
using v8::Global;
using v8::Exception;
using v8::CTypeInfo;
using v8::PropertyAttribute;
using v8::Signature;
using v8::ConstructorBehavior;
using v8::SideEffectType;
using v8::kPromiseRejectAfterResolved;
using v8::kPromiseResolveAfterResolved;
using v8::kPromiseHandlerAddedAfterReject;
using v8::Data;
using v8::PrimitiveArray;
using v8::TypedArray;
using v8::Uint8Array;
using v8::Boolean;
using v8::ModuleRequest;
using v8::CFunctionInfo;
using v8::OOMDetails;
using v8::V8;


#define JUST_MAX_HEADERS 128

typedef struct httpHeader httpHeader;
struct httpHeader {
  uint32_t name_start;
  uint32_t name_len;
  uint32_t value_start;
  uint32_t value_len;
};

typedef struct httpRequest httpRequest;
struct httpRequest {
  size_t path_len;
  size_t method_len;
  size_t num_headers;
  int32_t minor_version;
  uint8_t padding[4];
  struct httpHeader headers[JUST_MAX_HEADERS];
};

typedef struct httpResponse httpResponse;
struct httpResponse {
  int32_t minor_version;
  int32_t status_code;
  size_t num_headers;
  size_t status_message_len;
  uint8_t padding[8];
  struct httpHeader headers[JUST_MAX_HEADERS];
};

#ifdef __cplusplus
extern "C" {
#endif

int parse_request(char* next, ssize_t bytes, httpRequest* req);
int parse_response(char* next, ssize_t bytes, httpResponse* res);
// we can do the routing inside c++ if we pre-define the routes
#ifdef __cplusplus
}
#endif

// todo: read multiple headers in a single call - for pipelined
// todo: spec compliance checks
// todo: chunked parsing
int parse_request(char* next, ssize_t bytes, httpRequest* req) {
  const char* method;
  const char* path;
  struct phr_header headers[JUST_MAX_HEADERS];
  req->num_headers = JUST_MAX_HEADERS;
  int nread = phr_parse_request(next, bytes, 
    (const char **)&method, 
    &req->method_len, (const char **)&path, 
    &req->path_len, &req->minor_version, headers, 
    &req->num_headers, 0);
  for (uint32_t i = 0; i < req->num_headers; i++) {
    req->headers[i].name_start = (uint64_t)headers[i].name - (uint64_t)next;
    req->headers[i].name_len = headers[i].name_len;
    req->headers[i].value_start = (uint64_t)headers[i].value - (uint64_t)next;
    req->headers[i].value_len = headers[i].value_len;
  }
  return nread;
}

int parse_response(char* next, ssize_t bytes, httpResponse* res) {
  const char* status_message;
  struct phr_header headers[JUST_MAX_HEADERS];
  res->num_headers = JUST_MAX_HEADERS;
  int nread = phr_parse_response(next, bytes,
    &res->minor_version, &res->status_code, 
    (const char **)&status_message, 
    &res->status_message_len, headers, 
    &res->num_headers, 0);
  for (uint32_t i = 0; i < res->num_headers; i++) {
    res->headers[i].name_start = (uint64_t)headers[i].name - (uint64_t)next;
    res->headers[i].name_len = headers[i].name_len;
    res->headers[i].value_start = (uint64_t)headers[i].value - (uint64_t)next;
    res->headers[i].value_len = headers[i].value_len;
  }
  return nread;
}



int32_t parseRequestFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargsparseRequest[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcparseRequest = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoparseRequest = v8::CFunctionInfo(rcparseRequest, 4, cargsparseRequest);
v8::CFunction pFparseRequest = v8::CFunction((const void*)&parseRequestFast, &infoparseRequest);

int32_t parseRequest2Fast(void* p, void* p0, uint32_t p1, void* p2);
v8::CTypeInfo cargsparseRequest2[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcparseRequest2 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoparseRequest2 = v8::CFunctionInfo(rcparseRequest2, 4, cargsparseRequest2);
v8::CFunction pFparseRequest2 = v8::CFunction((const void*)&parseRequest2Fast, &infoparseRequest2);

int32_t parseResponseFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2);
v8::CTypeInfo cargsparseResponse[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint8, CTypeInfo::SequenceType::kIsTypedArray, CTypeInfo::Flags::kNone),
};
v8::CTypeInfo rcparseResponse = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoparseResponse = v8::CFunctionInfo(rcparseResponse, 4, cargsparseResponse);
v8::CFunction pFparseResponse = v8::CFunction((const void*)&parseResponseFast, &infoparseResponse);

int32_t parseResponse2Fast(void* p, void* p0, uint32_t p1, void* p2);
v8::CTypeInfo cargsparseResponse2[4] = {
  v8::CTypeInfo(v8::CTypeInfo::Type::kV8Value),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint32),
  v8::CTypeInfo(v8::CTypeInfo::Type::kUint64),
};
v8::CTypeInfo rcparseResponse2 = v8::CTypeInfo(v8::CTypeInfo::Type::kInt32);
v8::CFunctionInfo infoparseResponse2 = v8::CFunctionInfo(rcparseResponse2, 4, cargsparseResponse2);
v8::CFunction pFparseResponse2 = v8::CFunction((const void*)&parseResponse2Fast, &infoparseResponse2);



void parseRequestSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  char* v0 = reinterpret_cast<char*>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  httpRequest* v2 = reinterpret_cast<httpRequest*>(ptr2);
  int32_t rc = parse_request(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseRequestFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2) {
  char* v0 = reinterpret_cast<char*>(p0->data);
  uint32_t v1 = p1;
  httpRequest* v2 = reinterpret_cast<httpRequest*>(p2->data);
  return parse_request(v0, v1, v2);
}
void parseRequest2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  httpRequest* v2 = reinterpret_cast<httpRequest*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = parse_request(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseRequest2Fast(void* p, void* p0, uint32_t p1, void* p2) {
  char* v0 = reinterpret_cast<char*>(p0);
  uint32_t v1 = p1;
  httpRequest* v2 = reinterpret_cast<httpRequest*>(p2);
  return parse_request(v0, v1, v2);
}
void parseResponseSlow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  Local<Uint8Array> u80 = args[0].As<Uint8Array>();
  uint8_t* ptr0 = (uint8_t*)u80->Buffer()->Data() + u80->ByteOffset();
  char* v0 = reinterpret_cast<char*>(ptr0);
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  Local<Uint8Array> u82 = args[2].As<Uint8Array>();
  uint8_t* ptr2 = (uint8_t*)u82->Buffer()->Data() + u82->ByteOffset();
  httpResponse* v2 = reinterpret_cast<httpResponse*>(ptr2);
  int32_t rc = parse_response(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseResponseFast(void* p, struct FastApiTypedArray* const p0, uint32_t p1, struct FastApiTypedArray* const p2) {
  char* v0 = reinterpret_cast<char*>(p0->data);
  uint32_t v1 = p1;
  httpResponse* v2 = reinterpret_cast<httpResponse*>(p2->data);
  return parse_response(v0, v1, v2);
}
void parseResponse2Slow(const FunctionCallbackInfo<Value> &args) {
  Isolate *isolate = args.GetIsolate();
  char* v0 = reinterpret_cast<char*>((uint64_t)Local<Integer>::Cast(args[0])->Value());
  uint32_t v1 = Local<Integer>::Cast(args[1])->Value();
  httpResponse* v2 = reinterpret_cast<httpResponse*>((uint64_t)Local<Integer>::Cast(args[2])->Value());
  int32_t rc = parse_response(v0, v1, v2);
  args.GetReturnValue().Set(Number::New(isolate, rc));
}

int32_t parseResponse2Fast(void* p, void* p0, uint32_t p1, void* p2) {
  char* v0 = reinterpret_cast<char*>(p0);
  uint32_t v1 = p1;
  httpResponse* v2 = reinterpret_cast<httpResponse*>(p2);
  return parse_response(v0, v1, v2);
}

void Init(Isolate* isolate, Local<ObjectTemplate> target) {
  Local<ObjectTemplate> module = ObjectTemplate::New(isolate);
  SET_FAST_METHOD(isolate, module, "parseRequest", &pFparseRequest, parseRequestSlow);
  SET_FAST_METHOD(isolate, module, "parseRequest2", &pFparseRequest2, parseRequest2Slow);
  SET_FAST_METHOD(isolate, module, "parseResponse", &pFparseResponse, parseResponseSlow);
  SET_FAST_METHOD(isolate, module, "parseResponse2", &pFparseResponse2, parseResponse2Slow);

  SET_MODULE(isolate, target, "pico", module);
}
} // namespace pico
} // namespace spin

extern "C" {
  void* _register_pico() {
    return (void*)spin::pico::Init;
  }
}
